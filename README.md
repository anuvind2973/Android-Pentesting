
# Android Pentesting

Welcome to the Android Penetration Testing project! In this repository, we explore the fascinating world of securing Android applications through rigorous penetration testing techniques. 

## Table Of Contents

[*****Platform Overview*****](#Platform-Overview)
  * [***Linux kernel***](#Linux-kernel)
  * [***Hardware Abstraction Layer (HAL)***](#Hardware-Abstraction-Layer (HAL))
  * [***Android Runtime***](#Android-Runtime)
    * [**Android Runtime vs Dalvikl**](#Android-Runtime-vs-Dalvik)
  * [***Java API framework***](#Java-API-framework)
  * [***System apps***](#System-apps)
  * [***Android Native Development Kit (NDK) vs Android Software Development Kit (SDK)***](#Android-Native-Development-Kit-(NDK)-vs-Android-Software-Development-Kit-SDK)


## **Platform Overview**

Let's start with androd Arcitecturer overview 
Android is an open source, The foundation of the Android platform is the Linux kernel. Andrid is developed for ARM architeture and later expanded to support x86 and x86-64 architectuer.

![Alt text](https://github.com/anuvind2973/Android/blob/main/android-stack_2x.png)

## **Linux kernel**

The Linux kernel is the heart of the Android operating system.The Linux kernel was chosen for a variety of reasons. Most notably, Linux is a portable operating system that can be quickly built on a variety of hardware.The kernel serves as a layer of abstraction between the device's software and hardware.At the heart of the Android operating system lies a modified version of a Linux LTS kernel that interacts directly with the hardware.The Linux Kernel is the foundation layer of the Android architecture, responsible for managing hardware resources using drivers such as memory, CPU, and input/output. It also provides essential services such as security and process management.

## **Hardware Abstraction Layer (HAL)**

Hardware Abstraction Layer (HAL): The HAL layer provides an interface between the Android framework and the underlying hardware of the device. It is responsible for managing low-level hardware resources such as sensors, cameras, and audio hardware.

## **Android Runtime**

Android Runtime is the virtual machine that executes application code contained in Dalvik Executable (DEX) files. It manages code compilation, debugging, and garbage collection. Each application runs with its own instance of ART, i.e. in its own virtual machine, to ensure code isolation. ART replaced Dalvik as Android’s Java virtual machine in 2013 as its Ahead-of-Time compilation provided improved performance over the latter’s Just-in-Time compilation.


## **Android Runtime vs Dalvik**

What is runtime?
In a simplest term it is a system used by operating system which takes care of converting the code that you write in a high level language like Java to machine code and understand by CPU/Processor.

Runtime comprises of software instructions that execute when your program is running, even if they’re not essentially are a part of the code of that piece of software in particular.

CPUs or more general term our computers understand only machine language (binary codes) so to make it run on CPU, the code must be converted to machine code, which is done by translator.

So following are the generation of translator in a sequence-

1. Assemblers :
It directly translate assembly codes to machine codes so it was very fast.

2. Compilers :
It translates the code into assembly codes and then use assemblers to translate the code into binary. Using this compilation was slow but execution was fast. But the biggest problem with compiler is that the resulted machine code was platform dependent. In other words the code which runs on one machine may not run on different machine.

3. Interpreters :
It translates the code while executing it. Since the translation happens at runtime, the execution was slow.

How JAVA code execution works?
To maintain the platform independency of the code, JAVA developed JVM i.e. Java Virtual Machine. It developed JVM specific to every platform means JVM is dependency on the platform. The Java compiler converts the .java files into .class files, which is called byte code. This byte code is given to the JVM which converts it into machine code.

This is faster than interpretation but slower than C++ compilation.

How Android code execution works?
In Android Java classes converted into DEX bytecode. The DEX bytecode format is translated to native machine code via either ART or the Dalvik runtimes. Here DEX bytecode is independent of device architecture.

Dalvik is a JIT (Just in time) compilation based engine. There were drawbacks to use Dalvik hence from Android 4.4 (kitkat) ART was introduced as a runtime and from Android 5.0 (Lollipop) it has completely replaced Dalvik. Android 7.0 adds a just-in-time (JIT) compiler with code profiling to Android runtime (ART) that constantly improves the performance of Android apps as they run.

Key Point: Dalvik used JIT (Just in time) compilation whereas ART uses AOT (Ahead of time) compilation.

Below are the code snippet explaining the difference between Dalvik Virtual Machine and Java Virtual Machine.

![Alt text](https://github.com/anuvind2973/Android/blob/main/Image/1_kWHICeg5bjl5Av1u-wzx3w.webp)

Just In Time (JIT)
With the Dalvik JIT compiler, each time when the app is run, it dynamically translates a part of the Dalvik bytecode into machine code. As the execution progresses, more bytecode is compiled and cached. Since JIT compiles only a part of the code, it has a smaller memory footprint and uses less physical space on the device.

Ahead Of Time (AOT)
ART is equipped with an Ahead-of-Time compiler. During the app’s installation phase, it statically translates the DEX bytecode into machine code and stores in the device’s storage. This is a one-time event which happens when the app is installed on the device. With no need for JIT compilation, the code executes much faster.

As ART runs app machine code directly (native execution), it doesn’t hit the CPU as hard as just-in-time code compiling on Dalvik. Because of less CPU usage results in less battery drain.

![Alt text](https://github.com/anuvind2973/Android/blob/main/Image/1_pRQ0ygtGiskGSsiHrCROrw.webp)

ART also uses same DEX bytecode as input for Dalvik. An application compiled using ART requires additional time for compilation when an application is installed and take up slightly larger amounts of space to store the compiled code.

Why Android use Virtual Machine?
Android makes use of a virtual machine as its runtime environment in order to run the APK files that constitute an Android application. Below are the advantages:

· The application code is isolated from the core OS. So even if any code contains some malicious code won’t directly affect the system files. It makes the Android OS more stable and reliable.

· It provides cross compatibility or platform independency. It meaning even if an app is compiled on platform such as a PC, it can still be executed on the mobile platform using the virtual machine.

Benefits of ART
· Apps run faster as DEX bytecode translation done during installation.

· Reduces startup time of applications as native code is directly executed.

· Improves battery performance as power utilized to interpreted byte codes line by line is saved.

· Improved garbage collector.

· Improved developer tool.

Drawbacks of ART
· App Installation takes more time because of DEX bytecodes conversion into machine code during installation.

· As the native machine code generated on installation is stored in internal storage, more internal storage is required.

Conclusion
ART is written to run multiple virtual machines on low-memory devices by executing DEX files, a bytecode format designed specially for Android that’s optimized for minimal memory footprint. It makes the UI feel more responsive. That’s all from my side. For more details on ART and Dalvik you can go through official Android document.

## **Native C/C++ libraries**

Native C/C++ libraries are an essential part of the operating system as most core Android components are written in native code. The Java API framework is the gateway to the operating system for all user applications. It provides many services to applications in the form of Java API calls including the Activity, Resource and Notification managers, Content providers and the View system. This is why Android applications are mainly developed in Java, although the native libraries do provide some support for C/C++. More recently, Kotlin has also been supported, and even preferred by Google, for Android application development. The code is compiled by the Android Software Development Kit (SDK) and archived as an Android package (APK).


## **Java API framework**

The entire feature-set of the Android OS is available to you through APIs written in the Java language. These APIs form the building blocks you need to create Android apps by simplifying the reuse of core, modular system components and services, which include the following:

A rich and extensible view system you can use to build an app’s UI, including lists, grids, text boxes, buttons, and even an embeddable web browser
A resource manager, providing access to non-code resources such as localized strings, graphics, and layout files
A notification manager that enables all apps to display custom alerts in the status bar
An activity manager that manages the lifecycle of apps and provides a common navigation back stack
Content providers that enable apps to access data from other apps, such as the Contacts app, or to share their own data
Developers have full access to the same framework APIs that Android system apps use.

## **System apps**

Android comes with a set of core apps for email, SMS messaging, calendars, internet browsing, contacts, and more. Apps included with the platform have no special status among the apps the user chooses to install. So, a third-party app can become the user's default web browser, SMS messenger, or even the default keyboard. Some exceptions apply, such as the system's Settings app.

The system apps function both as apps for users and to provide key capabilities that developers can access from their own app. For example, if you want your app to deliver SMS messages, you don't need to build that functionality yourself. You can instead invoke whichever SMS app is already installed to deliver a message to the recipient you specify.


## **Android Native Development Kit (NDK) vs Android Software Development Kit (SDK)**


Android Native Development Kit (NDK) is a toolset that allows developers to reuse code written in C/C++ programming languages and incorporate it to their app through Java Native Interface (JNI). Since the app will run directly in the processor, instead of being interpreted by Dalvik Virtual Machine, it will gain some extra speed.

Besides, code written in C/C++ for Android can be easily ported and run in other platform such as iOS or Windows.  Useful if you develop a multi platform application.

NDK will also increase your app complexity, however, it will limit your app functionality. For this reason, you should know that it must be used only if it is essential to your app. First, look for Android framework APIs and check if they can provide you the functionality you need.

What is the difference?
Android Software Development Kit (SDK), on the other hand, uses Java programming language, and includes sample projects, development tools and Integrated Development Environment (IDE) Android Studio. It also provides all the common APIs used for Android apps.

It is important to mention that some Android Apps use NDK to achieve a specific functionality. That makes NDK and SDK somehow complementary in some cases. However, Android still recommends to only used NDK if you really need to.

With the help of online communities and forums, we elaborate a infographic that explain some of the main reasons to use one kit over the other:


Reasons to use NDK
Great for CPU intensive operations: mobile videogames, signal processing or physics simulations. Run computationally intensive applications.
Porting existing C/C++ code to Android.
Developing a multiplatform application (iOS, Windows).
Reasons to use SDK
Ensured device portability despite processor architecture
Rich set of libraries
Automatic memory management




 








- [@octokatherine](https://www.github.com/octokatherine)




























# Android
adb shell >su>/data/local/tmp/frida-server
To list packages : frida-ps -Uai
Objection -g (package here) explore
android root disable
android sslpinning disable
 
To run a frida script to bypass ssl pinning:
 
frida -l "C:\Users\SISARachesMohapatra\OneDrive - SISA Information Security Pvt. Ltd\Desktop\frida-server-16.0.19-android-x86_64\fridanscriptBest.js" -U -f <application-package-name>
