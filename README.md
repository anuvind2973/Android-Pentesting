
# Android Pentesting

Welcome to the Android Penetration Testing project! In this repository, we explore the fascinating world of securing Android applications through rigorous penetration testing techniques. 

## Table Of Contents

[*****Platform Overview*****](#Platform-Overview)
  * [Prerequisites](#prerequisites)
  * [Installation](#installation)
* [Built With](#built-with)
* [Getting Started](#getting-started)

* [Usage](#usage)
* [Roadmap](#roadmap)
* [Contributing](#contributing)
* [License](#license)
* [Authors](#authors)
* [Acknowledgements](#acknowledgements)



## **Platform Overview**

Let's start with androd Arcitecturer overview 
Android is an open source, The foundation of the Android platform is the Linux kernel. Andrid is developed for ARM architeture and later expanded to support x86 and x86-64 architectuer.

![Alt text](https://github.com/anuvind2973/Android/blob/main/android-stack_2x.png)

## **Linux kernel**

The Linux kernel is the heart of the Android operating system.The Linux kernel was chosen for a variety of reasons. Most notably, Linux is a portable operating system that can be quickly built on a variety of hardware.The kernel serves as a layer of abstraction between the device's software and hardware.At the heart of the Android operating system lies a modified version of a Linux LTS kernel that interacts directly with the hardware.The Linux Kernel is the foundation layer of the Android architecture, responsible for managing hardware resources using drivers such as memory, CPU, and input/output. It also provides essential services such as security and process management.

## **Hardware Abstraction Layer (HAL)**

Hardware Abstraction Layer (HAL): The HAL layer provides an interface between the Android framework and the underlying hardware of the device. It is responsible for managing low-level hardware resources such as sensors, cameras, and audio hardware.

## **Android Runtime**

Android Runtime is the virtual machine that executes application code contained in Dalvik Executable (DEX) files. It manages code compilation, debugging, and garbage collection. Each application runs with its own instance of ART, i.e. in its own virtual machine, to ensure code isolation. ART replaced Dalvik as Android’s Java virtual machine in 2013 as its Ahead-of-Time compilation provided improved performance over the latter’s Just-in-Time compilation.


## **Android Runtime vs Dalvik**

What is runtime?
In a simplest term it is a system used by operating system which takes care of converting the code that you write in a high level language like Java to machine code and understand by CPU/Processor.

Runtime comprises of software instructions that execute when your program is running, even if they’re not essentially are a part of the code of that piece of software in particular.

CPUs or more general term our computers understand only machine language (binary codes) so to make it run on CPU, the code must be converted to machine code, which is done by translator.

So following are the generation of translator in a sequence-

1. Assemblers :
It directly translate assembly codes to machine codes so it was very fast.

2. Compilers :
It translates the code into assembly codes and then use assemblers to translate the code into binary. Using this compilation was slow but execution was fast. But the biggest problem with compiler is that the resulted machine code was platform dependent. In other words the code which runs on one machine may not run on different machine.

3. Interpreters :
It translates the code while executing it. Since the translation happens at runtime, the execution was slow.

How JAVA code execution works?
To maintain the platform independency of the code, JAVA developed JVM i.e. Java Virtual Machine. It developed JVM specific to every platform means JVM is dependency on the platform. The Java compiler converts the .java files into .class files, which is called byte code. This byte code is given to the JVM which converts it into machine code.

This is faster than interpretation but slower than C++ compilation.

How Android code execution works?
In Android Java classes converted into DEX bytecode. The DEX bytecode format is translated to native machine code via either ART or the Dalvik runtimes. Here DEX bytecode is independent of device architecture.

Dalvik is a JIT (Just in time) compilation based engine. There were drawbacks to use Dalvik hence from Android 4.4 (kitkat) ART was introduced as a runtime and from Android 5.0 (Lollipop) it has completely replaced Dalvik. Android 7.0 adds a just-in-time (JIT) compiler with code profiling to Android runtime (ART) that constantly improves the performance of Android apps as they run.

Key Point: Dalvik used JIT (Just in time) compilation whereas ART uses AOT (Ahead of time) compilation.

Below are the code snippet explaining the difference between Dalvik Virtual Machine and Java Virtual Machine.

![Alt text]([https://github.com/anuvind2973/Android/blob/main/android-stack_2x.png](https://github.com/anuvind2973/Android/blob/main/Image/1_kWHICeg5bjl5Av1u-wzx3w.webp)

## **Android Native Development Kit (NDK) vs Android Software Development Kit (SDK)**


Android Native Development Kit (NDK) is a toolset that allows developers to reuse code written in C/C++ programming languages and incorporate it to their app through Java Native Interface (JNI). Since the app will run directly in the processor, instead of being interpreted by Dalvik Virtual Machine, it will gain some extra speed.

Besides, code written in C/C++ for Android can be easily ported and run in other platform such as iOS or Windows.  Useful if you develop a multi platform application.

NDK will also increase your app complexity, however, it will limit your app functionality. For this reason, you should know that it must be used only if it is essential to your app. First, look for Android framework APIs and check if they can provide you the functionality you need.

What is the difference?
Android Software Development Kit (SDK), on the other hand, uses Java programming language, and includes sample projects, development tools and Integrated Development Environment (IDE) Android Studio. It also provides all the common APIs used for Android apps.

It is important to mention that some Android Apps use NDK to achieve a specific functionality. That makes NDK and SDK somehow complementary in some cases. However, Android still recommends to only used NDK if you really need to.

With the help of online communities and forums, we elaborate a infographic that explain some of the main reasons to use one kit over the other:


Reasons to use NDK
Great for CPU intensive operations: mobile videogames, signal processing or physics simulations. Run computationally intensive applications.
Porting existing C/C++ code to Android.
Developing a multiplatform application (iOS, Windows).
Reasons to use SDK
Ensured device portability despite processor architecture
Rich set of libraries
Automatic memory management


 








- [@octokatherine](https://www.github.com/octokatherine)




























# Android
adb shell >su>/data/local/tmp/frida-server
To list packages : frida-ps -Uai
Objection -g (package here) explore
android root disable
android sslpinning disable
 
To run a frida script to bypass ssl pinning:
 
frida -l "C:\Users\SISARachesMohapatra\OneDrive - SISA Information Security Pvt. Ltd\Desktop\frida-server-16.0.19-android-x86_64\fridanscriptBest.js" -U -f <application-package-name>
