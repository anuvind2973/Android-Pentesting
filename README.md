
# Android Pentesting

##### Welcome to the Android Penetration Testing project! In this repository, we explore the fascinating world of securing Android applications through rigorous penetration testing techniques. 

## Table Of Contents

[*****Platform Overview*****](#Platform-Overview)
  * [***Linux kernel***](#Linux-kernel)
  * [***Hardware Abstraction Layer (HAL)***](#Hardware-Abstraction-Layer (HAL))
  * [***Android Runtime***](#Android-Runtime)
    * [**Android Runtime vs Dalvikl**](#Android-Runtime-vs-Dalvik)
  * [***Java API framework***](#Java-API-framework)
  * [***System apps***](#System-apps)
  * [***Android Native Development Kit (NDK) vs Android Software Development Kit (SDK)***](#Android-Native-Development-Kit-(NDK)-vs-Android-Software-Development-Kit-SDK)


## **Platform Overview**

Let's start with androd Arcitecturer overview 
Android is an open source, The foundation of the Android platform is the Linux kernel. Andrid is developed for ARM architeture and later expanded to support x86 and x86-64 architectuer.

![Alt text](https://github.com/anuvind2973/Android/blob/main/android-stack_2x.png)

## **Linux kernel**

The Linux kernel is the heart of the Android operating system.The Linux kernel was chosen for a variety of reasons. Most notably, Linux is a portable operating system that can be quickly built on a variety of hardware.The kernel serves as a layer of abstraction between the device's software and hardware.At the heart of the Android operating system lies a modified version of a Linux LTS kernel that interacts directly with the hardware.The Linux Kernel is the foundation layer of the Android architecture, responsible for managing hardware resources using drivers such as memory, CPU, and input/output. It also provides essential services such as security and process management.

## **Hardware Abstraction Layer (HAL)**

Hardware Abstraction Layer (HAL): The HAL layer provides an interface between the Android framework and the underlying hardware of the device. It is responsible for managing low-level hardware resources such as sensors, cameras, and audio hardware.

## **Android Runtime**

Android Runtime is the virtual machine that executes application code contained in Dalvik Executable (DEX) files. It manages code compilation, debugging, and garbage collection. Each application runs with its own instance of ART, i.e. in its own virtual machine, to ensure code isolation. ART replaced Dalvik as Android’s Java virtual machine in 2013 as its Ahead-of-Time compilation provided improved performance over the latter’s Just-in-Time compilation.


## **Android Runtime vs Dalvik**

What is runtime?
In a simplest term it is a system used by operating system which takes care of converting the code that you write in a high level language like Java to machine code and understand by CPU/Processor.

Runtime comprises of software instructions that execute when your program is running, even if they’re not essentially are a part of the code of that piece of software in particular.

CPUs or more general term our computers understand only machine language (binary codes) so to make it run on CPU, the code must be converted to machine code, which is done by translator.

So following are the generation of translator in a sequence-

1. Assemblers :
It directly translate assembly codes to machine codes so it was very fast.

2. Compilers :
It translates the code into assembly codes and then use assemblers to translate the code into binary. Using this compilation was slow but execution was fast. But the biggest problem with compiler is that the resulted machine code was platform dependent. In other words the code which runs on one machine may not run on different machine.

3. Interpreters :
It translates the code while executing it. Since the translation happens at runtime, the execution was slow.

How JAVA code execution works?
To maintain the platform independency of the code, JAVA developed JVM i.e. Java Virtual Machine. It developed JVM specific to every platform means JVM is dependency on the platform. The Java compiler converts the .java files into .class files, which is called byte code. This byte code is given to the JVM which converts it into machine code.

This is faster than interpretation but slower than C++ compilation.

How Android code execution works?
In Android Java classes converted into DEX bytecode. The DEX bytecode format is translated to native machine code via either ART or the Dalvik runtimes. Here DEX bytecode is independent of device architecture.

Dalvik is a JIT (Just in time) compilation based engine. There were drawbacks to use Dalvik hence from Android 4.4 (kitkat) ART was introduced as a runtime and from Android 5.0 (Lollipop) it has completely replaced Dalvik. Android 7.0 adds a just-in-time (JIT) compiler with code profiling to Android runtime (ART) that constantly improves the performance of Android apps as they run.

Key Point: Dalvik used JIT (Just in time) compilation whereas ART uses AOT (Ahead of time) compilation.

Below are the code snippet explaining the difference between Dalvik Virtual Machine and Java Virtual Machine.

![Alt text](https://github.com/anuvind2973/Android/blob/main/Image/1_kWHICeg5bjl5Av1u-wzx3w.webp)

Just In Time (JIT)
With the Dalvik JIT compiler, each time when the app is run, it dynamically translates a part of the Dalvik bytecode into machine code. As the execution progresses, more bytecode is compiled and cached. Since JIT compiles only a part of the code, it has a smaller memory footprint and uses less physical space on the device.

Ahead Of Time (AOT)
ART is equipped with an Ahead-of-Time compiler. During the app’s installation phase, it statically translates the DEX bytecode into machine code and stores in the device’s storage. This is a one-time event which happens when the app is installed on the device. With no need for JIT compilation, the code executes much faster.

As ART runs app machine code directly (native execution), it doesn’t hit the CPU as hard as just-in-time code compiling on Dalvik. Because of less CPU usage results in less battery drain.

![Alt text](https://github.com/anuvind2973/Android/blob/main/Image/1_pRQ0ygtGiskGSsiHrCROrw.webp)

ART also uses same DEX bytecode as input for Dalvik. An application compiled using ART requires additional time for compilation when an application is installed and take up slightly larger amounts of space to store the compiled code.

Why Android use Virtual Machine?
Android makes use of a virtual machine as its runtime environment in order to run the APK files that constitute an Android application. Below are the advantages:

· The application code is isolated from the core OS. So even if any code contains some malicious code won’t directly affect the system files. It makes the Android OS more stable and reliable.

· It provides cross compatibility or platform independency. It meaning even if an app is compiled on platform such as a PC, it can still be executed on the mobile platform using the virtual machine.

Benefits of ART
· Apps run faster as DEX bytecode translation done during installation.

· Reduces startup time of applications as native code is directly executed.

· Improves battery performance as power utilized to interpreted byte codes line by line is saved.

· Improved garbage collector.

· Improved developer tool.

Drawbacks of ART
· App Installation takes more time because of DEX bytecodes conversion into machine code during installation.

· As the native machine code generated on installation is stored in internal storage, more internal storage is required.

Conclusion
ART is written to run multiple virtual machines on low-memory devices by executing DEX files, a bytecode format designed specially for Android that’s optimized for minimal memory footprint. It makes the UI feel more responsive. That’s all from my side. For more details on ART and Dalvik you can go through official Android document.

## **Native C/C++ libraries**

Native C/C++ libraries are an essential part of the operating system as most core Android components are written in native code. The Java API framework is the gateway to the operating system for all user applications. It provides many services to applications in the form of Java API calls including the Activity, Resource and Notification managers, Content providers and the View system. This is why Android applications are mainly developed in Java, although the native libraries do provide some support for C/C++. More recently, Kotlin has also been supported, and even preferred by Google, for Android application development. The code is compiled by the Android Software Development Kit (SDK) and archived as an Android package (APK).


## **Java API framework**

The entire feature-set of the Android OS is available to you through APIs written in the Java language. These APIs form the building blocks you need to create Android apps by simplifying the reuse of core, modular system components and services, which include the following:

A rich and extensible view system you can use to build an app’s UI, including lists, grids, text boxes, buttons, and even an embeddable web browser
A resource manager, providing access to non-code resources such as localized strings, graphics, and layout files
A notification manager that enables all apps to display custom alerts in the status bar
An activity manager that manages the lifecycle of apps and provides a common navigation back stack
Content providers that enable apps to access data from other apps, such as the Contacts app, or to share their own data
Developers have full access to the same framework APIs that Android system apps use.

## **System apps**

Android comes with a set of core apps for email, SMS messaging, calendars, internet browsing, contacts, and more. Apps included with the platform have no special status among the apps the user chooses to install. So, a third-party app can become the user's default web browser, SMS messenger, or even the default keyboard. Some exceptions apply, such as the system's Settings app.

The system apps function both as apps for users and to provide key capabilities that developers can access from their own app. For example, if you want your app to deliver SMS messages, you don't need to build that functionality yourself. You can instead invoke whichever SMS app is already installed to deliver a message to the recipient you specify.


## **Android Native Development Kit (NDK) vs Android Software Development Kit (SDK)**


Android Native Development Kit (NDK) is a toolset that allows developers to reuse code written in C/C++ programming languages and incorporate it to their app through Java Native Interface (JNI). Since the app will run directly in the processor, instead of being interpreted by Dalvik Virtual Machine, it will gain some extra speed.

Besides, code written in C/C++ for Android can be easily ported and run in other platform such as iOS or Windows.  Useful if you develop a multi platform application.

NDK will also increase your app complexity, however, it will limit your app functionality. For this reason, you should know that it must be used only if it is essential to your app. First, look for Android framework APIs and check if they can provide you the functionality you need.

What is the difference?
Android Software Development Kit (SDK), on the other hand, uses Java programming language, and includes sample projects, development tools and Integrated Development Environment (IDE) Android Studio. It also provides all the common APIs used for Android apps.

It is important to mention that some Android Apps use NDK to achieve a specific functionality. That makes NDK and SDK somehow complementary in some cases. However, Android still recommends to only used NDK if you really need to.

With the help of online communities and forums, we elaborate a infographic that explain some of the main reasons to use one kit over the other:


Reasons to use NDK
Great for CPU intensive operations: mobile videogames, signal processing or physics simulations. Run computationally intensive applications.
Porting existing C/C++ code to Android.
Developing a multiplatform application (iOS, Windows).
Reasons to use SDK
Ensured device portability despite processor architecture
Rich set of libraries
Automatic memory management


## System and kernel security 


At the operating system level, the Android platform provides the security of the Linux kernel, as well as a secure inter-process communication (IPC) facility to enable secure communication between applications running in different processes. These security features at the OS level ensure that even native code is constrained by the Application Sandbox. 

### Linux Security

As the base for a mobile computing environment, the Linux kernel provides Android with several key security features, including:

A user-based permissions model
Process isolation
Extensible mechanism for secure IPC
The ability to remove unnecessary and potentially insecure parts of the kernel
As a multiuser operating system, a fundamental security objective of the Linux kernel is to isolate user resources from one another. The Linux security philosophy is to protect user resources from one another.


#### The Application Sandbox

The Android platform takes advantage of the Linux user-based protection to identify and isolate app resources. This isolates apps from each other and protects apps and the system from malicious apps. To do this, Android assigns a unique user ID (UID) to each Android application and runs it in its own process.

Android uses the UID to set up a kernel-level Application Sandbox. The kernel enforces security between apps and the system at the process level through standard Linux facilities such as user and group IDs that are assigned to apps. By default, apps can't interact with each other and have limited access to the OS. If app A tries to do something malicious, such as read application B's data or dial the phone without permission, it's prevented from doing so because it doesn't have the appropriate default user privileges. The sandbox is simple, auditable, and based on decades-old UNIX-style user separation of processes and file permissions.

Because the Application Sandbox is in the kernel, this security model extends to both native code and OS applications. All of the software above the kernel, such as OS libraries, application framework, application runtime, and all applications, run within the Application Sandbox. On some platforms, developers are constrained to a specific development framework, set of APIs, or language. On Android, there are no restrictions on how an application can be written that are required to enforce security; in this respect, native code is as sandboxed as interpreted code.

#### System Partition and Safe Mode

The various integrity protected partitions contain Android's kernel as well as the operating system libraries, application runtime, application framework, and applications. This partition is set to read-only. When a user boots the device into Safe Mode, third-party applications may be launched manually by the device owner but are not launched by default.

####Filesystem Permissions

In a UNIX-style environment, filesystem permissions ensure that one user cannot alter or read another user's files. In the case of Android, each application runs as its own user. Unless the developer explicitly shares files with other applications, files created by one application cannot be read or altered by another application.

#### Security-Enhanced Linux

As part of the Android security model, Android uses Security-Enhanced Linux (SELinux) to enforce mandatory access control (MAC) over all processes, even processes running with root/superuser privileges (Linux capabilities). Many companies and organizations have contributed to Android's SELinux implementation. With SELinux, Android can better protect and confine system services, control access to application data and system logs, reduce the effects of malicious software, and protect users from potential flaws in code on mobile devices.

SELinux operates on the principle of default denial: Anything not explicitly allowed is denied. SELinux can operate in two global modes:

Permissive mode, in which permission denials are logged but not enforced.
Enforcing mode, in which permissions denials are both logged and enforced.
Android includes SELinux in enforcing mode and a corresponding security policy that works by default across AOSP. In enforcing mode, disallowed actions are prevented and all attempted violations are logged by the kernel to dmesg and logcat. When developing, you should use these errors to refine your software and SELinux policies before enforcing them. For more details, see Implementing SELinux.

SELinux also supports a per-domain permissive mode in which specific domains (processes) can be made permissive while placing the rest of the system in global enforcing mode. A domain is simply a label identifying a process or set of processes in the security policy, where all processes labeled with the same domain are treated identically by the security policy. Per-domain permissive mode enables incremental application of SELinux to an ever-increasing portion of the system and policy development for new services (while keeping the rest of the system enforcing).

#### Verified boot
Android 7.0 and later supports strictly enforced verified boot, which means compromised devices cannot boot. Verified boot guarantees the integrity of the device software starting from a hardware root of trust up to the system partition. During boot, each stage cryptographically verifies the integrity and authenticity of the next stage before executing it.
See Verified boot for more details.

#### Rooting of Devices

By default, on Android only the kernel and a small subset of the core services run with root permissions. SELinux still constrains user space processes running as root. Verified boot prevents a user or service with root permissions from permanently modifying the operating system.

The ability to modify an Android device they own is important to developers working with the Android platform. On many Android devices, users have the ability to unlock the bootloader in order to allow installation of an alternate operating system. These alternate operating systems may allow an owner to gain root access for purposes of debugging applications and system components or to access features not presented to applications by Android APIs.

On some devices, a person with physical control of a device and a USB cable is able to install a new operating system that provides root privileges to the user. To protect any existing user data from compromise the bootloader unlock mechanism requires that the bootloader erase any existing user data as part of the unlock step. Root access gained via exploiting a kernel bug or security hole can bypass this protection.

Encrypting data with a key stored on-device does not protect the application data from root users on rooted devices. Applications can add a layer of data protection using encryption with a key stored off-device, such as on a server or a user password. This approach can provide temporary protection while the key is not present, but at some point the key must be provided to the application and it then becomes accessible to root users.

A more robust approach to protecting data from root users is through the use of hardware solutions. OEMs may choose to implement hardware solutions that limit access to specific types of content such as DRM for video playback, or the NFC-related trusted storage for Google wallet. In the case of a lost or stolen device, storage encryption ensures that user data cannot be accessed without knowing the user's lockscreen credential.

### User Security Features

#### Storage Encryption

The CDD requires that all devices that launch with Android 10 or higher, and most devices that launch with Android 6.0 or higher, enable storage encryption out of the box.

Android's current implementation of storage encryption is file-based encryption in combination with metadata encryption. File-based encryption transparently encrypts file contents and names on the userdata partition, using different keys for different directories. It provides credential-encrypted and device-encrypted storage directories for each user, including work profiles.

Metadata encryption complements file-based encryption. It encrypts all blocks on the userdata partition that aren't already encrypted by file-based encryption, using a key not bound to any user's lockscreen credential but still protected by Verified Boot.

#### Lockscreen Credential Protection 

Android can be configured to verify a user-supplied lockscreen credential (PIN, password, or pattern) prior to providing access to a device. In addition to preventing unauthorized use of the device, the lockscreen credential protects the cryptographic key for credential-encrypted data. Use of a lockscreen credential and/or credential complexity rules can be required by a device administrator.

#### Device Administration

Android 2.2 and later provide the Android Device Administration API, which provides device administration features at the system level. For example, the built-in Android Email application uses the APIs to improve Exchange support. Through the Email application, Exchange administrators can enforce lockscreen credential policies — including alphanumeric passwords or numeric PINs — across devices. Administrators can also remotely wipe (that is, restore factory defaults on) lost or stolen handsets.


- [@octokatherine](https://www.github.com/octokatherine)
- [Introduction to Android Security](https://medium.com/mobis3c/introduction-to-android-security-64609edeb18c)
- [Inter-Process Communication](https://medium.com/@the_daft_introvert/inter-process-communication-in-operating-systems-a-comprehensive-guide-with-real-life-examples-and-c508cf3bfb1a)





















# Android
adb shell >su>/data/local/tmp/frida-server
To list packages : frida-ps -Uai
Objection -g (package here) explore
android root disable
android sslpinning disable
 
To run a frida script to bypass ssl pinning:
 
frida -l "C:\Users\SISARachesMohapatra\OneDrive - SISA Information Security Pvt. Ltd\Desktop\frida-server-16.0.19-android-x86_64\fridanscriptBest.js" -U -f <application-package-name>
